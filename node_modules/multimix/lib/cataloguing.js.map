{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/cataloguing.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n'use strict'\n\n\n#===========================================================================================================\n# OBJECT PROPERTY CATALOGUING\n#-----------------------------------------------------------------------------------------------------------\n@keys_of              = ( P... ) -> @values_of @walk_keys_of      P...\n@all_keys_of          = ( P... ) -> @values_of @walk_all_keys_of  P...\n@all_own_keys_of      = ( x    ) -> if x? then Object.getOwnPropertyNames x else []\n@walk_all_own_keys_of = ( x    ) -> yield k for k in @all_own_keys_of x\n\n#-----------------------------------------------------------------------------------------------------------\n@walk_keys_of = ( x, settings ) ->\n  defaults = { skip_undefined: true, }\n  settings = { defaults..., settings..., }\n  for k of x\n    ### TAINT should use property descriptors to avoid possible side effects ###\n    continue if ( x[ k ] is undefined ) and settings.skip_undefined\n    yield k\n\n#-----------------------------------------------------------------------------------------------------------\n@walk_all_keys_of = ( x, settings ) ->\n  defaults = { skip_object: true, skip_undefined: true, }\n  settings = { defaults..., settings..., }\n  return @_walk_all_keys_of x, new Set(), settings\n\n#-----------------------------------------------------------------------------------------------------------\n@_walk_all_keys_of = ( x, seen, settings ) ->\n  if ( not settings.skip_object ) and x is Object::\n    yield return\n  #.........................................................................................................\n  for k from @walk_all_own_keys_of x\n    continue if seen.has k\n    seen.add k\n    ### TAINT should use property descriptors to avoid possible side effects ###\n    ### TAINT trying to access `arguments` causes error ###\n    try value = x[ k ] catch error then continue\n    continue if ( value is undefined ) and settings.skip_undefined\n    if settings.symbol?\n      continue unless value?\n      continue unless value[ settings.symbol ]\n    yield k\n  #.........................................................................................................\n  if ( proto = Object.getPrototypeOf x )?\n    yield from @_walk_all_keys_of proto, seen, settings\n\n#-----------------------------------------------------------------------------------------------------------\n### Turn iterators into lists, copy lists: ###\n@values_of = ( x ) -> [ x... ]\n\n#-----------------------------------------------------------------------------------------------------------\n@has_keys = ( x, P... ) ->\n  ### Observe that `has_keys()` always considers `undefined` as 'not set' ###\n  return false unless x? ### TAINT or throw error ###\n  for key in P.flat Infinity\n    ### TAINT should use property descriptors to avoid possible side effects ###\n    return false if x[ key ] is undefined\n  return true\n\n#-----------------------------------------------------------------------------------------------------------\n@has_key = ( x, key ) -> @has_keys x, key\n\n#-----------------------------------------------------------------------------------------------------------\n@has_only_keys = ( x, P... ) ->\n  probes  = ( P.flat Infinity ).sort()\n  keys    = ( @values_of @keys_of x ).sort()\n  return probes.length = keys.length and probes.every ( x, idx ) -> x == keys[ idx ]\n\n"
  ]
}