{
  "version": 3,
  "file": "suspend.js",
  "sourceRoot": "..",
  "sources": [
    "src/suspend.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\nCND = require '..'\n\n### original code from https://github.com/jmar777/suspend. ###\n\n\n#-----------------------------------------------------------------------------------------------------------\nsuspend = ( context, generatorfn ) ->\n  ### Like `https://github.com/jmar777/suspend`, but:\n  * written in CoffeeScript;\n  * works with callback-accepting *synchronous* functions (see below comment);\n  * this means using `suspend` (or `step`) will make your code asynchronous in case it wasn't already;\n  * will throw errors in the generatorfn by default;\n  * will send only a single value (not a list with a single value) to the generatorfn if the function\n    calling back did so with a single argument (otherwise no change);\n  * offers utility functions for your asynchronous chores (available as `suspend.step`, `suspend.after`, and\n    `suspend.eventually`);\n  * more utilities possible in the future. ###\n  # do_throw = options?[ 'throw' ] ? yes\n  #.........................................................................................................\n  switch arity = arguments.length\n    when 1 then [ context, generatorfn, ] = [ null, context, ]\n    when 2 then null\n    else throw new Error \"expected 1 or 2 arguments, got #{arity}\"\n  #.........................................................................................................\n  unless ( type = CND.type_of generatorfn ) is 'generatorfunction'\n    throw new Error \"expected a generator function, got a #{type}\"\n  #.........................................................................................................\n  return ->\n    #.......................................................................................................\n    Array::unshift.call arguments, ( error ) ->\n      _arguments = arguments\n      #.....................................................................................................\n      ### Here we postpone sending errors and values until the next turn of the event loop; this will\n      prevent `Generator is already running` errors in case a non-asynchronous function happened to be\n      called. ###\n      suspend.eventually ->\n        # if do_throw\n        return iterator.throw error if error?\n        if _arguments.length < 3\n          iterator.next _arguments[ 1 ]\n        else\n          iterator.next Array::slice.call _arguments, 1\n        # else\n        #   iterator.next Array::slice.call _arguments\n    #.......................................................................................................\n    # context   ?= this\n    iterator = generatorfn.apply context, arguments\n    return if iterator.next? then iterator.next() else null\n\n#-----------------------------------------------------------------------------------------------------------\n### Like `suspend`, but executing the suspended function immediately. ###\nsuspend.step = ( P... ) -> ( suspend P... )()\n\n#-----------------------------------------------------------------------------------------------------------\nsuspend.wrap = suspend.step.wrap = ( method, handler ) ->\n  ### Since i've found that rarely some functions don't like to be called using `yield f resume`, i've added\n  `suspend.wrap` (a.k.a. `suspend.step.wrap`) as a very thin wrapper that avoids such problems; simply\n  call `yield step.wrap f, resume` in such cases. ###\n  method -> handler()\n\n#-----------------------------------------------------------------------------------------------------------\nsuspend.after = ( time_s, handler ) ->\n  ### `after` is a shim for `setTimeout` that adheres to NodeJS conventions, taking a `handler`\n  callback function as last argument. Also, the timeout is given in humane seconds rather than in ms. ###\n  return setTimeout handler, time_s * 1000\n\n#-----------------------------------------------------------------------------------------------------------\nsuspend.eventually = ( handler ) ->\n  ### `eventually f` is just another name for `process.nextTick f`â€”which in turn is basically equivalent to\n  `after 0, f`. ###\n  return process.nextTick handler\n\n#-----------------------------------------------------------------------------------------------------------\nsuspend.immediately = ( handler ) ->\n  ### `immediately f` is just another name for `setImmediate f`, which is very similar to\n  `process.nextTick`. ###\n  return setImmediate handler\n\n#-----------------------------------------------------------------------------------------------------------\nsuspend.repeat_immediately = ( method ) ->\n  ### Accepts a function that should (when called without arguments) return a trueish or a falsey value\n  to indicate whether to (when trueish) continue repeating or else (when falsey) stop repeating. The\n  method will be called right after calling `repeat_immediately` itself for the first time. Depending on\n  the return value, it will be scheduled to be run again with `setImmediate` semantics (i.e. like being\n  scheduled with `setTimeout f, 0`) as long as it doesn't return a falsey value. ###\n  f = ->\n    return unless method()\n    setImmediate f\n  f()\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\nsuspend.every = ( time_s, handler ) ->\n  ### `every` is a shim for `setIntervall` that adheres to NodeJS conventions, taking a `handler`\n  callback function as last argument. Also, the timeout is given in humane seconds rather than in ms. ###\n  return setInterval handler, time_s * 1000\n\n#-----------------------------------------------------------------------------------------------------------\nsuspend.collect = ( method, P..., handler ) ->\n  ### `collect` is a convenience method for asynchronous functions that comply with the following interface:\n  * They accept a number of arguments, the last of whioch is a callback handler.\n  * The callback handler accepts an `error` and one or more `data` arguments.\n  * The function will call with an unspecified number of data items.\n  * After the last callback has fired, one more callback with no data item or a a single `undefined` or\n    `null` is fired to signal termination.\n  * When termination has been signalled and after an error has occurred, no more callbacks are performed.\n\n  `collect` will collect all values in a list, which will be sent to the callback handler; there will be no\n  extra call to signal completion. Each time `collect` receives data, it looks whether it has received one\n  or more arguments; if there was one argument, that argument will be pushed into the rsults list; if there\n  were more arguments, a list with those values is pushed. The number of data items may differ from callback\n  to callback.\n\n  Usage example:\n\n      step ( resume ) ->*\n        lines = yield collect read_lines_of, route, resume\n        log lines\n\n  Mind the comma after the function name in the exampleâ€”that function must be passed as the first argument,\n  not called at this point in time. Also Remeber that in JavaScript, passing `library.method` will in most\n  cases make `method` 'forget' about its `this` context, in this case `library`. As a workaround, you may\n  want to write\n\n      lines = yield collect ( library.read_lines_of.bind library ), route, resume\n\n  instead. This is a well-known, if unfortunate fact about JavaScript; proposals on how to better deal with\n  this situation are welcome. ###\n  Z             = []\n  has_finished  = no\n  #.........................................................................................................\n  finish = ->\n    has_finished  = yes\n    handler null, Z\n  #.........................................................................................................\n  method P..., ( error, data... ) ->\n    throw new Error \"`collect` was called after having finished\" if has_finished\n    return handler error if error?\n    switch data.length\n      when 0\n        finish()\n      when 1\n        first_item    = data[ 0 ]\n        first_item   ?= null\n        return finish() if first_item is null\n        Z.push first_item\n      else\n        Z.push data\n  #.........................................................................................................\n  return null\n\n\n############################################################################################################\nmodule.exports = suspend\n\n"
  ]
}