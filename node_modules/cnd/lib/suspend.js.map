{
  "version": 3,
  "file": "suspend.js",
  "sourceRoot": "..",
  "sources": [
    "src/suspend.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\nCND = require '..'\n\n### original code from https://github.com/jmar777/suspend. ###\n\n\n#-----------------------------------------------------------------------------------------------------------\nsuspend = ( context, generatorfn ) ->\n  ### Like `https://github.com/jmar777/suspend`, but:\n  * written in CoffeeScript;\n  * works with callback-accepting *synchronous* functions (see below comment);\n  * this means using `suspend` (or `step`) will make your code asynchronous in case it wasn't already;\n  * will throw errors in the generatorfn by default;\n  * will send only a single value (not a list with a single value) to the generatorfn if the function\n    calling back did so with a single argument (otherwise no change);\n  * offers utility functions for your asynchronous chores (available as `suspend.step`, `suspend.after`, and\n    `suspend.eventually`);\n  * more utilities possible in the future. ###\n  # do_throw = options?[ 'throw' ] ? yes\n  #.........................................................................................................\n  switch arity = arguments.length\n    when 1 then [ context, generatorfn, ] = [ null, context, ]\n    when 2 then null\n    else throw new Error \"expected 1 or 2 arguments, got #{arity}\"\n  #.........................................................................................................\n  unless ( type = CND.type_of generatorfn ) is 'generatorfunction'\n    throw new Error \"expected a generator function, got a #{type}\"\n  #.........................................................................................................\n  return ->\n    #.......................................................................................................\n    Array::unshift.call arguments, ( error ) ->\n      _arguments = arguments\n      #.....................................................................................................\n      ### Here we postpone sending errors and values until the next turn of the event loop; this will\n      prevent `Generator is already running` errors in case a non-asynchronous function happened to be\n      called. ###\n      suspend.eventually ->\n        # if do_throw\n        return iterator.throw error if error?\n        if _arguments.length < 3\n          iterator.next _arguments[ 1 ]\n        else\n          iterator.next Array::slice.call _arguments, 1\n        # else\n        #   iterator.next Array::slice.call _arguments\n    #.......................................................................................................\n    # context   ?= this\n    iterator = generatorfn.apply context, arguments\n    return if iterator.next? then iterator.next() else null\n\n#-----------------------------------------------------------------------------------------------------------\n### Like `suspend`, but executing the suspended function immediately. ###\nsuspend.step = ( P... ) -> ( suspend P... )()\n\n#-----------------------------------------------------------------------------------------------------------\nsuspend.wrap = suspend.step.wrap = ( method, handler ) ->\n  ### Since i've found that rarely some functions don't like to be called using `yield f resume`, i've added\n  `suspend.wrap` (a.k.a. `suspend.step.wrap`) as a very thin wrapper that avoids such problems; simply\n  call `yield step.wrap f, resume` in such cases. ###\n  method -> handler()\n\n#-----------------------------------------------------------------------------------------------------------\nsuspend.after = ( time_s, handler ) ->\n  ### `after` is a shim for `setTimeout` that adheres to NodeJS conventions, taking a `handler`\n  callback function as last argument. Also, the timeout is given in humane seconds rather than in ms. ###\n  return setTimeout handler, time_s * 1000\n\n#-----------------------------------------------------------------------------------------------------------\nsuspend.eventually = ( handler ) ->\n  ### `eventually f` is just another name for `process.nextTick f`—which in turn is basically equivalent to\n  `after 0, f`. ###\n  return process.nextTick handler\n\n#-----------------------------------------------------------------------------------------------------------\nsuspend.immediately = ( handler ) ->\n  ### `immediately f` is just another name for `setImmediate f`, which is very similar to\n  `process.nextTick`. ###\n  return setImmediate handler\n\n#-----------------------------------------------------------------------------------------------------------\nsuspend.repeat_immediately = ( method ) ->\n  ### Accepts a function that should (when called without arguments) return a trueish or a falsey value\n  to indicate whether to (when trueish) continue repeating or else (when falsey) stop repeating. The\n  method will be called right after calling `repeat_immediately` itself for the first time. Depending on\n  the return value, it will be scheduled to be run again with `setImmediate` semantics (i.e. like being\n  scheduled with `setTimeout f, 0`) as long as it doesn't return a falsey value. ###\n  f = ->\n    return unless method()\n    setImmediate f\n  f()\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\nsuspend.every = ( time_s, handler ) ->\n  ### `every` is a shim for `setIntervall` that adheres to NodeJS conventions, taking a `handler`\n  callback function as last argument. Also, the timeout is given in humane seconds rather than in ms. ###\n  return setInterval handler, time_s * 1000\n\n#-----------------------------------------------------------------------------------------------------------\nsuspend.collect = ( method, P..., handler ) ->\n  ### `collect` is a convenience method for asynchronous functions that comply with the following interface:\n  * They accept a number of arguments, the last of whioch is a callback handler.\n  * The callback handler accepts an `error` and one or more `data` arguments.\n  * The function will call with an unspecified number of data items.\n  * After the last callback has fired, one more callback with no data item or a a single `undefined` or\n    `null` is fired to signal termination.\n  * When termination has been signalled and after an error has occurred, no more callbacks are performed.\n\n  `collect` will collect all values in a list, which will be sent to the callback handler; there will be no\n  extra call to signal completion. Each time `collect` receives data, it looks whether it has received one\n  or more arguments; if there was one argument, that argument will be pushed into the rsults list; if there\n  were more arguments, a list with those values is pushed. The number of data items may differ from callback\n  to callback.\n\n  Usage example:\n\n      step ( resume ) ->*\n        lines = yield collect read_lines_of, route, resume\n        log lines\n\n  Mind the comma after the function name in the example—that function must be passed as the first argument,\n  not called at this point in time. Also Remeber that in JavaScript, passing `library.method` will in most\n  cases make `method` 'forget' about its `this` context, in this case `library`. As a workaround, you may\n  want to write\n\n      lines = yield collect ( library.read_lines_of.bind library ), route, resume\n\n  instead. This is a well-known, if unfortunate fact about JavaScript; proposals on how to better deal with\n  this situation are welcome. ###\n  Z             = []\n  has_finished  = no\n  #.........................................................................................................\n  finish = ->\n    has_finished  = yes\n    handler null, Z\n  #.........................................................................................................\n  method P..., ( error, data... ) ->\n    throw new Error \"`collect` was called after having finished\" if has_finished\n    return handler error if error?\n    switch data.length\n      when 0\n        finish()\n      when 1\n        first_item    = data[ 0 ]\n        first_item   ?= null\n        return finish() if first_item is null\n        Z.push first_item\n      else\n        Z.push data\n  #.........................................................................................................\n  return null\n\n\n############################################################################################################\nmodule.exports = suspend\n\n"
  ]
}