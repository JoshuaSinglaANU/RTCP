{
  "version": 3,
  "file": "ito.js",
  "sourceRoot": "../..",
  "sources": [
    "src/experiments/ito.coffee"
  ],
  "names": [],
  "mappings": ";AAEA;EAAA;AAAA,MAAA,GAAA,EAAA,KAAA,EAAA,KAAA,EAAA,IAAA,EAAA,IAAA,EAAA,IAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,OAAA,EAAA,IAAA,EAAA,QAAA,EAAA,IAAA,EAAA,OAAA;IAAA,kBAAA;;;EAIA,GAAA,GAA4B,OAAA,CAAQ,KAAR;;EAC5B,GAAA,GAA4B,GAAG,CAAC;;EAChC,KAAA,GAA4B;;EAC5B,KAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,OAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAC5B,OAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,SAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,IAAI,CAAC,IAAT,CAAc,GAAd,EAb5B;;;EAeA,CAAA,CAAE,EAAF,CAAA,GAA4B,GAA5B,EAfA;;;EAiBA,CAAA,CAAE,GAAF,EACE,QADF,EAEE,OAFF,CAAA,GAE4B,OAAA,CAAQ,SAAR,CAF5B,EAjBA;;;;;;EA0BA,IAAC,CAAA,OAAD,GAAW,MAAM,CAAC,MAAP,CACT;IAAA,IAAA,EAAkB,MAAA,CAAO,MAAP,CAAlB;EAAA,CADS,EA1BX;;;;;;EAgCA,IAAC,CAAA,KAAD,GAAS,MAAM,CAAC,MAAP,CACP;IAAA,UAAA,EAAkB,MAAA,CAAO,YAAP,CAAlB;EAAA,CADO,EAhCT;;;;;;;EAuCA,IAAC,CAAA,IAAD,GAAQ,MAAA,CAAO,YAAP,EAvCR;;;;;EA4CA,IAAC,CAAA,KAAD,GAAU,IAAC,CAAA,CAAD,GAAK,QAAA,CAAA,GAAE,SAAF,CAAA;AACf,QAAA,KAAA,EAAA,CAAA,EAAA,GAAA,EAAA,IAAA,EAAA,IAAA,EAAA,CAAA,EAAA;4CAD+B;IAC7B,QAAQ,CAAC,QAAT,CAAkB,SAAlB;IACA,IAAyE,CAAE,KAAA,GAAQ,SAAS,CAAC,MAApB,CAAA,KAAgC,CAAzG;MAAA,MAAM,IAAI,KAAJ,CAAU,CAAA,uBAAA,CAAA,CAA0B,KAA1B,CAAA,gBAAA,CAAV,EAAN;;IACA,IAA0C,SAAS,CAAC,MAAV,GAAmB,CAA7D;AAAA,aAAO,IAAC,CAAA,MAAD,CAAQ,GAAA,SAAR,EAAsB,SAAtB,EAAP;;IACA,CAAA,GAAQ;IACR,IAAA,GAAQ,IAAI,CAAC;IACb,CAAA,GAAQ,QAAA,CAAE,CAAF,EAAK,IAAL,CAAA;aAAe,SAAA,CAAU,CAAV,EAAa,IAAb;IAAf;AACR,WAAO,SAAG,IAAC,CAAA,WAAJ,EAAW,CAAX,EAAc,CAAd,EAAiB,IAAjB;EAPM;;EA5Cf;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA",
  "sourcesContent": [
    "\n\n'use strict'\n\n\n############################################################################################################\nCND                       = require 'cnd'\nrpr                       = CND.rpr\nbadge                     = 'STEAMPIPES/EXPERIMENTS/ITO'\ndebug                     = CND.get_logger 'debug',     badge\nwarn                      = CND.get_logger 'warn',      badge\ninfo                      = CND.get_logger 'info',      badge\nurge                      = CND.get_logger 'urge',      badge\nhelp                      = CND.get_logger 'help',      badge\nwhisper                   = CND.get_logger 'whisper',   badge\necho                      = CND.echo.bind CND\n#...........................................................................................................\n{ jr }                    = CND\n#...........................................................................................................\n{ isa\n  validate\n  type_of }               = require './types'\n\n\n#===========================================================================================================\n#\n#-----------------------------------------------------------------------------------------------------------\n### Signals are special values that, when sent down the pipeline, may alter behavior: ###\n@signals = Object.freeze\n  last:             Symbol 'last'             # Used to signal last data item\n  # end:              Symbol 'end'              # Request stream to terminate\n\n#-----------------------------------------------------------------------------------------------------------\n### Marks are special values that identify types, behavior of pipeline elements etc: ###\n@marks = Object.freeze\n  steampipes:       Symbol 'steampipes'       # Marks steampipes objects\n  # validated:        Symbol 'validated'        # Marks a validated sink\n  # isa_duct:         Symbol 'isa_duct'         # Marks a duct as such\n  # isa_pusher:       Symbol 'isa_pusher'       # Marks a push source as such\n  # send_last:        Symbol 'send_last'        # Marks transforms expecting a certain value before EOS\n  # async:            Symbol 'async'            # Marks transforms as asynchronous (experimental)\n@seal = Symbol 'steampipes'\n\n#===========================================================================================================\n#\n#-----------------------------------------------------------------------------------------------------------\n@remit  = @$ = ( modifiers..., transform ) ->\n  validate.function transform\n  throw new Error \"µ20123 transform arity #{arity} not implemented\" unless ( arity = transform.length ) is 2\n  return @modify modifiers..., transform if modifiers.length > 0\n  o     = []\n  send  = sink.push\n  t     = ( d, send ) -> transform d, send\n  return { [@seal], t, o, send, }\n\n# #-----------------------------------------------------------------------------------------------------------\n# @$async = ( method ) ->\n#   ### TAINT incomplete implementation: surround, leapfrog arguments missing ###\n#   throw new Error \"µ77644 surround arguments not yet implemented\" unless arguments.length is 1\n#   throw new Error \"µ77644 method arity #{arity} not implemented\" unless ( arity = method.length ) is 3\n#   resolve = null\n#   done    = ->\n#     throw new Error \"µ82081 arguments not allowed\" unless arguments.length is 0\n#     resolve()\n#   R = ( d, send ) => return new Promise ( resolve_ ) =>\n#     resolve = resolve_\n#     await method d, send, done\n#   R[ @marks.async ] = @marks.async\n#   return R\n\n# #-----------------------------------------------------------------------------------------------------------\n# @_classify_sink = ( transform ) ->\n#   @_$drain transform unless transform[ @marks.validated ]?\n#   R = { type: 'sink', }\n\n# #-----------------------------------------------------------------------------------------------------------\n# @_classify_transform = ( transform ) ->\n#   R = do =>\n#     return { type: transform.type,              } if transform[ @marks.isa_duct   ]?\n#     return { type: 'source', isa_pusher: true,  } if transform[ @marks.isa_pusher ]?\n#     return { type: 'source',                    } if transform[ Symbol.iterator   ]?\n#     return @_classify_sink transform              if ( isa.object transform ) and transform.sink?\n#     switch type = type_of transform\n#       when 'function'           then return { type: 'through', }\n#       when 'generatorfunction'  then return { type: 'source', must_call: true, }\n#     throw new Error \"µ44521 expected an iterable, a function, a generator function or a sink, got a #{type}\"\n#   R.mode = if transform[ @marks.async ]? then 'async' else 'sync'\n#   return R\n\n# #-----------------------------------------------------------------------------------------------------------\n# @_flatten_transforms = ( transforms, R = null ) ->\n#   R ?= []\n#   for transform in transforms\n#     if transform[ @marks.isa_duct ]?\n#       ### TAINT necessary to do this recursively? ###\n#       R.push t for t in transform.transforms\n#     else\n#       R.push transform\n#   return R\n\n# #-----------------------------------------------------------------------------------------------------------\n# @_new_duct = ( transforms ) ->\n#   transforms  = @_flatten_transforms transforms\n#   blurbs      = ( @_classify_transform transform for transform in transforms )\n#   R           = { [@marks.steampipes], [@marks.isa_duct], transforms, blurbs, }\n#   R.mode      = if ( blurbs.some ( blurb ) -> blurb.mode is 'async' ) then 'async' else 'sync'\n#   if transforms.length is 0\n#     R.is_empty = true\n#     return R\n#   #.........................................................................................................\n#   R.first = blurbs[ 0 ]\n#   if transforms.length is 1\n#     R.is_single   = true\n#     R.last        = R.first\n#     R.type        = R.first.type\n#   else\n#     R.last        = blurbs[ transforms.length - 1 ]\n#     switch key = \"#{R.first.type}/#{R.last.type}\"\n#       when 'source/through'   then R.type = 'source'\n#       when 'through/sink'     then R.type = 'sink'\n#       when 'through/through'  then R.type = 'through'\n#       when 'source/sink'      then R.type = 'circuit'\n#       else throw new Error \"µ44521 illegal duct configuration #{rpr key}\"\n#     for idx in [ 1 ... blurbs.length - 1 ] by +1\n#       unless ( b = blurbs[ idx ] ).type is 'through'\n#         throw new Error \"µ44522 illegal duct configuration at transform index #{idx}: #{rpr b}\"\n#   return R\n\n# #-----------------------------------------------------------------------------------------------------------\n# @_pull = ( transforms... ) ->\n#   duct                  = @_new_duct transforms\n#   { transforms, }       = duct\n#   original_source       = null\n#   throw new Error \"µ77764 source as last transform not yet supported\" if duct.last.type  is 'source'\n#   throw new Error \"µ77765 sink as first transform not yet supported\"  if duct.first.type is 'sink'\n#   #.........................................................................................................\n#   if duct.first.type is 'source'\n#     transforms[ 0 ] = transforms[ 0 ]() if duct.first.must_call\n#     source          = transforms[ 0 ]\n#   #.........................................................................................................\n#   return duct unless duct.type is 'circuit'\n#   #.........................................................................................................\n#   drain                 = transforms[ transforms.length - 1 ]\n#   duct.buckets          = buckets = ( transforms[ idx ].sink for idx in [ 1 ... transforms.length - 1 ] )\n#   debug 'µ12009', transforms\n#   duct.buckets.push drain.sink if drain.use_sink\n#   duct.has_ended        = false\n#   local_sink            = null\n#   local_source          = null\n#   has_local_sink        = null\n#   last                  = @signals.last\n#   last_transform_idx    = buckets.length - if drain.use_sink then 2 else 1\n#   tf_idxs               = [ 0 .. last_transform_idx ]\n#   #.........................................................................................................\n#   send = ( d ) =>\n#     return duct.has_ended = true if d is @signals.end\n#     local_sink.push d if has_local_sink\n#     return null\n#   send.end = => duct.has_ended = true\n#   #.........................................................................................................\n#   exhaust_pipeline = =>\n#     loop\n#       data_count    = 0\n#       # for transform, idx in transforms\n#       for idx in tf_idxs\n#         continue if ( local_source = buckets[ idx ] ).length is 0\n#         transform       = transforms[  idx + 1 ]\n#         local_sink      = buckets[ idx + 1 ]\n#         has_local_sink  = local_sink?\n#         d               = local_source.shift()\n#         data_count     += local_source.length\n#         if d is last\n#           transform d, send if transform[ @marks.send_last ]?\n#           send last unless idx is last_transform_idx\n#         else\n#           transform d, send\n#       break if data_count is 0\n#     return null\n#   #.........................................................................................................\n#   exhaust_async_pipeline = =>\n#     loop\n#       data_count    = 0\n#       # for transform, idx in transforms\n#       for idx in tf_idxs\n#         continue if ( local_source = buckets[ idx ] ).length is 0\n#         transform       = transforms[  idx + 1 ]\n#         local_sink      = buckets[ idx + 1 ]\n#         has_local_sink  = local_sink?\n#         d               = local_source.shift()\n#         data_count     += local_source.length\n#         if transform[ @marks.async ]?\n#           if d is last\n#             await transform d, send if transform[ @marks.send_last ]?\n#             send last unless idx is last_transform_idx\n#           else\n#             await transform d, send\n#         else\n#           if d is last\n#             transform d, send if transform[ @marks.send_last ]?\n#             send last unless idx is last_transform_idx\n#           else\n#             transform d, send\n#       break if data_count is 0\n#     return null\n#   #.........................................................................................................\n#   duct.send                   = send\n#   duct.exhaust_pipeline       = exhaust_pipeline\n#   duct.exhaust_async_pipeline = exhaust_async_pipeline\n#   #.........................................................................................................\n#   return duct\n\n# #-----------------------------------------------------------------------------------------------------------\n# @pull = ( transforms... ) ->\n#   duct = @_pull transforms...\n#   return duct unless duct.type is 'circuit'\n#   return @_pull_async duct if duct.mode is 'async'\n#   return @_push duct if duct.transforms[ 0 ][ @marks.isa_pusher ]?\n#   first_bucket = duct.buckets[ 0 ]\n#   #.........................................................................................................\n#   for d from duct.transforms[ 0 ]\n#     break if duct.has_ended\n#     # continue if d is @signals.discard\n#     first_bucket.push d\n#     duct.exhaust_pipeline()\n#   #.........................................................................................................\n#   first_bucket.push @signals.last\n#   duct.exhaust_pipeline()\n#   drain = duct.transforms[ duct.transforms.length - 1 ]\n#   if ( on_end = drain.on_end )?\n#     if drain.call_with_datoms then drain.on_end drain.sink else drain.on_end()\n#   return duct\n\n# #-----------------------------------------------------------------------------------------------------------\n# @_pull_async = ( duct ) ->\n#   return duct unless duct.type is 'circuit'\n#   return @_push duct if duct.transforms[ 0 ][ @marks.isa_pusher ]?\n#   first_bucket = duct.buckets[ 0 ]\n#   #.........................................................................................................\n#   for d from duct.transforms[ 0 ]\n#     break if duct.has_ended\n#     # continue if d is @signals.discard\n#     first_bucket.push d\n#     await duct.exhaust_async_pipeline()\n#   #.........................................................................................................\n#   first_bucket.push @signals.last\n#   await duct.exhaust_async_pipeline()\n#   drain = duct.transforms[ duct.transforms.length - 1 ]\n#   if ( on_end = drain.on_end )?\n#     if drain.call_with_datoms then drain.on_end drain.sink else drain.on_end()\n#   return duct\n\n# #-----------------------------------------------------------------------------------------------------------\n# @_push = ( duct ) ->\n#   ### Make `duct` available from the POV of the push source: ###\n#   source        = duct.transforms[ 0 ]\n#   source.duct   = duct\n#   ### copy buffered data (from before when `pull()` was called) to `source`: ###\n#   first_bucket  = duct.buckets[ 0 ]\n#   first_bucket.splice first_bucket.length, 0, source.buffer...\n#   ### Process any data as may have accumulated at this point: ###\n#   if duct.mode is 'async' then  await duct.exhaust_async_pipeline()\n#   else                          duct.exhaust_pipeline()\n#   return null\n\n\n"
  ]
}