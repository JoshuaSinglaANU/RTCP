// Generated by CoffeeScript 2.4.1
(function() {
  'use strict';
  var $, $async, CND, ICQL, PATH, PD, _drop_extension, assign, badge, boolean_as_int, cwd_abspath, cwd_relpath, debug, echo, help, here_abspath, info, inspect, join_path, jr, project_abspath, rpr, select, urge, warn, whisper, xrpr, xrpr2;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'SQLITE-BROWSER/DB';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  PATH = require('path');

  // FS                        = require 'fs'
  PD = require('pipedreams');

  ({$, $async, select} = PD);

  ({assign, jr} = CND);

  ({cwd_abspath, cwd_relpath, here_abspath, _drop_extension, project_abspath} = require('./helpers'));

  //...........................................................................................................
  join_path = function(...P) {
    return PATH.resolve(PATH.join(...P));
  };

  boolean_as_int = function(x) {
    if (x) {
      return 1;
    } else {
      return 0;
    }
  };

  ({inspect} = require('util'));

  xrpr = function(x) {
    return inspect(x, {
      colors: true,
      breakLength: 2e308,
      maxArrayLength: 2e308,
      depth: 2e308
    });
  };

  xrpr2 = function(x) {
    return inspect(x, {
      colors: true,
      breakLength: 80,
      maxArrayLength: 2e308,
      depth: 2e308
    });
  };

  //...........................................................................................................
  ICQL = require('icql');

  //-----------------------------------------------------------------------------------------------------------
  this._get_icql_settings = function(db_path) {
    var R, defaults;
    defaults = {
      connector: require('better-sqlite3'),
      /* TAINT stopgap, will be moved into ICQL */db_path: db_path,
      icql_path: project_abspath('./db/sqlite-browser.icql'),
      clear: false
    };
    R = assign({}, defaults);
    R.db_path = cwd_abspath(R.db_path);
    R.icql_path = cwd_abspath(R.icql_path);
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.new_db = function(db_path) {
    var clear_count, db, settings;
    settings = this._get_icql_settings(db_path);
    db = ICQL.bind(settings);
    this.load_extensions(db);
    this.set_pragmas(db);
    //.........................................................................................................
    if (settings.clear) {
      clear_count = db.$.clear();
    }
    //.........................................................................................................
    this.create_db_functions(db);
    return db;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.set_pragmas = function(db) {
    db.$.pragma('foreign_keys = on');
    db.$.pragma('synchronous = off');
    /* see https://sqlite.org/pragma.html#pragma_synchronous */    db.$.pragma('journal_mode = WAL');
//.........................................................................................................
/* see https://github.com/JoshuaWise/better-sqlite3/issues/125 */    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.load_extensions = function(db) {
    return null;
  };

  // extensions_path = project_abspath './sqlite-for-mingkwai-ime/extensions'
  // debug 'µ39982', "extensions_path", extensions_path
  // db.$.load join_path extensions_path, 'spellfix.so'
  // db.$.load join_path extensions_path, 'csv.so'
  // db.$.load join_path extensions_path, 'regexp.so'
  // db.$.load join_path extensions_path, 'series.so'
  // db.$.load join_path extensions_path, 'nextchar.so'
  // # db.$.load join_path extensions_path, 'stmt.so'
  // #.........................................................................................................
  // return null

  //-----------------------------------------------------------------------------------------------------------
  this.create_db_functions = function(db) {
    // db.$.function 'add_spellfix_confusable', ( a, b ) ->
    // db.$.function 'spellfix1_phonehash', ( x ) ->
    //   debug '23363', x
    //   return x.toUpperCase()

    //---------------------------------------------------------------------------------------------------------
    db.$.function('echo', {
      deterministic: false,
      varargs: true
    }, function(...P) {
      /* Output text to command line. */
      /* TAINT consider to use logging method to output to app console. */
      urge(CND.grey('DB'), ...P);
      return null;
    });
    //---------------------------------------------------------------------------------------------------------
    db.$.function('e', {
      deterministic: false,
      varargs: false
    }, function(x) {
      /* Output text to command line, but returns single input value so can be used within an expression. */
      urge(CND.grey('DB'), rpr(x));
      return x;
    });
    //---------------------------------------------------------------------------------------------------------
    db.$.function('e', {
      deterministic: false,
      varargs: false
    }, function(mark, x) {
      /* Output text to command line, but returns single input value so can be used within an expression. */
      urge(CND.grey(`DB ${mark}`), rpr(x));
      return x;
    });
    //---------------------------------------------------------------------------------------------------------
    db.$.function('contains_word', {
      deterministic: true,
      varargs: false
    }, function(text, probe) {
      if (((' ' + text + ' ').indexOf(' ' + probe + ' ')) > -1) {
        return 1;
      } else {
        return 0;
      }
    });
    //---------------------------------------------------------------------------------------------------------
    db.$.function('get_words', {
      deterministic: true,
      varargs: false
    }, function(text) {
      var word;
      /* Given a text, return a JSON array with words (whitespace-separated non-empty substrings). */
      return JSON.stringify((function() {
        var i, len, ref, results;
        ref = text.split(/\s+/);
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          word = ref[i];
          if (word !== '') {
            results.push(word);
          }
        }
        return results;
      })());
    });
    // #---------------------------------------------------------------------------------------------------------
    // db.$.function 'vnr_encode_textual', { deterministic: true, varargs: false }, ( vnr ) ->
    //   ( ( "#{idx}".padStart 6, '0' ) for idx in ( JSON.parse vnr ) ).join '-'

    //---------------------------------------------------------------------------------------------------------
    db.$.function('vnr_encode', {
      deterministic: true,
      varargs: false
    }, function(vnr) {
      var error;
      try {
        return Uint32Array.from(JSON.parse(vnr));
      } catch (error1) {
        error = error1;
        warn(`µ33211 when trying to convert ${xrpr2(vnr)}`);
        warn("µ33211 to a typed array, an error occurred:");
        warn(`µ33211 ${error.message}`);
        throw error;
      }
    });
    //---------------------------------------------------------------------------------------------------------
    return null;
  };

}).call(this);

//# sourceMappingURL=db.js.map
