// Generated by CoffeeScript 2.5.1
(function() {
  'use strict';
  var CND, alert, badge, debug, echo, help, info, log, rpr, urge, warn, whisper,
    splice = [].splice;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPESTREAMS/EXPERIMENTS/SPAWN';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  //===========================================================================================================
  // SPAWN
  //-----------------------------------------------------------------------------------------------------------
  this.spawn_collect = function(...P) {
    var $on_data, handler, pipeline, ref, source;
    ref = P, [...P] = ref, [handler] = splice.call(P, -1);
    //.........................................................................................................
    $on_data = () => {
      var command, stderr, stdout;
      command = null;
      stderr = [];
      stdout = [];
      return this.$watch((event) => {
        var key, value;
        [key, value] = event;
        switch (key) {
          case 'command':
            command = value;
            break;
          case 'stdout':
            stdout.push(value);
            break;
          case 'stderr':
            stderr.push(value);
            break;
          case 'exit':
            return handler(null, Object.assign({command, stdout, stderr}, value));
          default:
            throw new Error("µ37718 internal error 2201991");
        }
        return null;
      });
    };
    //.........................................................................................................
    source = this.spawn(...P);
    pipeline = [];
    //.........................................................................................................
    pipeline.push(source);
    pipeline.push($on_data());
    pipeline.push(this.$drain());
    //.........................................................................................................
    pull(...pipeline);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.spawn = function(...P) {
    return (this._spawn(...P))[1];
  };

  //-----------------------------------------------------------------------------------------------------------
  this._spawn = function(command, settings) {
    var $ensure_event_order, arity, command_source, command_type, comments, confluence, cp, error_to_exit, event_buffer, event_pipeline, funnel, on_data, source, stderr, stderr_pipeline, stdout, stdout_is_binary, stdout_pipeline;
    //.........................................................................................................
    switch (arity = arguments.length) {
      case 1:
      case 2:
        null;
        break;
      default:
        throw new Error(`µ38483 expected 1 or 2 arguments, got ${arity}`);
    }
    //.........................................................................................................
    // throw new Error "µ39248 deprecated setting: error_to_exit" if ( pluck settings, 'error_to_exit',  null )?
    // stderr_target     = pluck settings, 'stderr', 'stderr'
    settings = Object.assign({
      shell: true
    }, settings);
    stdout_is_binary = pluck(settings, 'binary', false);
    comments = pluck(settings, 'comments', {});
    on_data = pluck(settings, 'on_data', null);
    error_to_exit = pluck(settings, 'error_to_exit', false);
    command_source = this.new_value_source([['command', command]]);
    //.........................................................................................................
    switch (command_type = CND.type_of(command)) {
      case 'text':
        cp = CP.spawn(command, settings);
        break;
      case 'list':
        if (!(command.length > 0)) {
          throw new Error(`µ40013 expected a list with at least one value, got ${rpr(command)}`);
        }
        cp = CP.spawn(command[0], command.slice(1), settings);
        break;
      default:
        throw new Error(`µ40778 expected a text or a list for command, got ${command_type}`);
    }
    //.........................................................................................................
    stdout = STPS.source(cp.stdout);
    stderr = STPS.source(cp.stderr);
    //.........................................................................................................
    stdout_pipeline = [];
    stderr_pipeline = [];
    funnel = [];
    event_pipeline = [];
    event_buffer = [];
    //.........................................................................................................
    stdout_pipeline.push(stdout);
    if (!stdout_is_binary) {
      stdout_pipeline.push(this.$split());
    }
    // stdout_pipeline.push @async_map ( data, handler ) -> defer -> handler null, data
    stdout_pipeline.push(this.map(function(line) {
      return ['stdout', line];
    }));
    //.........................................................................................................
    stderr_pipeline.push(stderr);
    stderr_pipeline.push(this.$split());
    // stderr_pipeline.push @$show title: '**44321**'
    // stderr_pipeline.push @async_map ( data, handler ) -> defer -> handler null, data
    stderr_pipeline.push(this.map(function(line) {
      return ['stderr', line];
    }));
    //.........................................................................................................
    /* Event handling: collect all events from child process */
    cp.on('disconnect', () => {
      return event_buffer.push(['disconnect', null]);
    });
    /* TAINT exit and error events should use same method to do post-processing */
    cp.on('error', (error) => {
      return event_buffer.push(['error', error != null ? error : null]);
    });
    cp.on('exit', (code, signal) => {
      var comment, ref, ref1, ref2, ref3;
      if ((signal != null) && (code == null)) {
        // debug '77100-1'
        code = 128 + ((ref = this._spawn._signals_and_codes[signal]) != null ? ref : 0);
      }
      // debug '77100-2'
      comment = (ref1 = (ref2 = comments[code]) != null ? ref2 : this._spawn._codes_and_comments[code]) != null ? ref1 : signal;
      // debug '77100-3'
      if (comment == null) {
        comment = code === 0 ? 'ok' : (ref3 = comments['error']) != null ? ref3 : 'error';
      }
      // debug '77100-4'
      return event_buffer.push(['exit', {code, signal, comment}]);
    });
    //.......................................................................................................
    /* The 'close' event should always come last, so we use that to trigger asynchronous sending of
     all events collected in the signal buffer. See https://github.com/dominictarr/pull-cont */
    event_pipeline.push(pull_cont((handler) => {
      return cp.on('close', () => {
        handler(null, this.new_value_source(event_buffer));
        return null;
      });
    }));
    //.........................................................................................................
    /* Since reading from a spawned process is inherently asynchronous, we cannot be sure all of the output
     from stdout and stderr has been sent down the pipeline before events from the child process arrive.
     Therefore, we have to buffer those events and send them on only when the confluence stream has indicated
     exhaustion: */
    $ensure_event_order = () => {
      var command_sent, cp_buffer, std_buffer;
      cp_buffer = [];
      std_buffer = [];
      command_sent = false;
      return this.$('null', (event, send) => {
        var category;
        if (event != null) {
          [category] = event;
          /* Events from stdout and stderr are buffered until the command event has been sent; after that,
                 they are sent immediately: */
          if (category === 'stdout' || category === 'stderr') {
            // debug '10921>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>', command_sent, std_buffer
            // send [ 'stderr', '!!!!!!!!!!!!!!!', ]
            if (command_sent) {
              if (on_data != null) {
                return on_data(event);
              } else {
                return send(event);
              }
            }
            return std_buffer.push(event);
          }
          /* The command event is sent right away; any buffered stdout, stderr events are flushed: */
          if (category === 'command') {
            command_sent = true;
            send(event);
            while (std_buffer.length > 0) {
              if (on_data != null) {
                on_data(std_buffer.shift());
              } else {
                send(std_buffer.shift());
              }
            }
            return;
          }
          /* Keep everything else (i.e. events from child process) for later: */
          cp_buffer.push(event);
        } else {
          while (cp_buffer.length > 0) {
            /* Send all buffered CP events: */
            send(cp_buffer.shift());
          }
        }
        // if on_data? then on_data std_buffer.shift() else send std_buffer.shift()
        return null;
      });
    };
    //.........................................................................................................
    confluence = pull_many([pull(command_source), pull(...stdout_pipeline), pull(...stderr_pipeline), pull(...event_pipeline)]);
    //.........................................................................................................
    funnel.push(confluence);
    funnel.push($ensure_event_order());
    // funnel.push @$show title: '**21129**'
    //.........................................................................................................
    if (error_to_exit) {
      funnel.push((() => {
        var error;
        error = [];
        return this.$((event, send) => {
          var key, value;
          if (event != null) {
            [key, value] = event;
            switch (key) {
              case 'command':
              case 'stdout':
                return send(event);
              case 'stderr':
                return error.push(value.trimRight());
              case 'exit':
                value.error = error.join('\n');
                if (value.error.length === 0) {
                  value.error = null;
                }
                return send(event);
              default:
                throw new Error("µ41543 internal error 110918");
            }
          }
        });
      })());
    }
    //.........................................................................................................
    source = pull(...funnel);
    return [cp, source];
  };

  //-----------------------------------------------------------------------------------------------------------
  this._spawn._signals_and_codes = {
    SIGHUP: 1,
    SIGINT: 2,
    SIGQUIT: 3,
    SIGILL: 4,
    SIGTRAP: 5,
    SIGABRT: 6,
    SIGIOT: 6,
    SIGBUS: 7,
    SIGFPE: 8,
    SIGKILL: 9,
    SIGUSR1: 10,
    SIGSEGV: 11,
    SIGUSR2: 12,
    SIGPIPE: 13,
    SIGALRM: 14,
    SIGTERM: 15,
    SIGSTKFLT: 16,
    SIGCHLD: 17,
    SIGCONT: 18,
    SIGSTOP: 19,
    SIGTSTP: 20,
    SIGTTIN: 21,
    SIGTTOU: 22,
    SIGURG: 23,
    SIGXCPU: 24,
    SIGXFSZ: 25,
    SIGVTALRM: 26,
    SIGPROF: 27,
    SIGWINCH: 28,
    SIGIO: 29,
    SIGPOLL: 29,
    SIGPWR: 30,
    SIGSYS: 31
  };

  //-----------------------------------------------------------------------------------------------------------
  this._spawn._codes_and_comments = {
    // 1:      'an error has occurred'
    126: 'permission denied',
    127: 'command not found'
  };

}).call(this);

//# sourceMappingURL=spawn.js.map
