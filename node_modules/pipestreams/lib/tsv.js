// Generated by CoffeeScript 2.5.1
(function() {
  'use strict';
  var CND, badge, debug, echo, flatten, help, info, rpr, urge, warn, whisper,
    indexOf = [].indexOf;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'PIPESTREAMS/TSV';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  flatten = require('lodash.flattendeep');

  //-----------------------------------------------------------------------------------------------------------
  this.$name_fields = function(...names) {
    names = flatten(names);
    return this.$((fields, send) => {
      var R, i, idx, len, name, type, value;
      if ((type = CND.type_of(fields)) !== 'list') {
        throw new Error(`µ43613 expected a list, got a ${type}`);
      }
      R = {};
      for (idx = i = 0, len = fields.length; i < len; idx = ++i) {
        value = fields[idx];
        name = names[idx] != null ? names[idx] : names[idx] = `field_${idx}`;
        R[name] = value;
      }
      return send(R);
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$split_on_tabs = function(settings) {
    return this.$((line, send) => {
      var type;
      if ((type = CND.type_of(line)) !== 'text') {
        `µ27918 expected a text, got a ${type}`;
      }
      return send(line.split(/\t/));
    });
  };

  // #-----------------------------------------------------------------------------------------------------------
  // @$split_on_whitespace = ( field_count = null ) ->
  //   if ( field_count is 0 )
  //     throw new Error "µ43714 field_count can not be zero"
  //   #.........................................................................................................
  //   ### If user requested null or zero fields, we can just split the line: ###
  //   if ( not field_count? ) # or ( field_count is 0 )
  //     return @$ ( line, send ) => send line.split /\s+/
  //   #.........................................................................................................
  //   ### If user requested one field, then the entire line is the field: ###
  //   if field_count is 1
  //     return @$ ( line, send ) => send [ line, ]
  //   #.........................................................................................................
  //   ### TAINT validate field_count is integer ###
  //   ### TAINT validate field_count is non-negative ###
  //   return @$ ( line, send ) =>
  //     "µ28239 expected a text, got a #{type}" unless ( type = CND.type_of line ) is 'text'
  //     fields  = []
  //     parts   = line.split /(\s+)/
  //     pairs   = ( [ parts[ idx ], parts[ idx + 1 ] ? '' ] for idx in [ 0 ... parts.length ] by +2 )
  //     #.......................................................................................................
  //     ### Shift-push line contents from `pairs` into `fields` until exhausted or saturated: ###
  //     loop
  //       break if pairs.length <= 0
  //       break if fields.length >= field_count - 1
  //       fields.push pairs.shift()[ 0 ]
  //     #.......................................................................................................
  //     ### Concat remaining parts and add as one more field: ###
  //     if pairs.length > 0
  //       fields.push ( ( ( fld + spc ) for [ fld, spc, ] in pairs ).join '' ).trim()
  //     #.......................................................................................................
  //     ### Pad missing fields with `null`: ###
  //     ### TAINT allow to configure padding value ###
  //     fields.push null while fields.length < field_count
  //     #.......................................................................................................
  //     send fields

  //-----------------------------------------------------------------------------------------------------------
  this.$split_on_whitespace = function(field_count = null) {
    var get_pattern, pattern;
    //.........................................................................................................
    if (field_count === 0) {
      throw new Error("µ43815 field_count can not be zero");
    }
    //.........................................................................................................
    /* If called with field_count `null`, we can just split the line: */
    if (field_count == null) {
      return this.$((line, send) => {
        var R, p;
        R = (function() {
          var i, len, ref, results;
          ref = line.split(/\s+/);
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            p = ref[i];
            results.push(p === '' ? null : p);
          }
          return results;
        })();
        while (R[R.length - 1] === null) {
          R.pop();
        }
        return send(R);
      });
    }
    //.........................................................................................................
    /* If user requested one field, then the entire line is the field: */
    if (field_count === 1) {
      return this.$((line, send) => {
        return send([line]);
      });
    }
    //.........................................................................................................
    get_pattern = (field_count) => {
      var R, _, i, ref, subpattern;
      // return /^(*){1,}$/ if ( not field_count? ) or ( field_count is 0 )
      R = [];
      subpattern = [];
      R.push('^');
      for (_ = i = 1, ref = field_count - 1; i <= ref; _ = i += +1) {
        subpattern.push('(\\S*)');
      }
      R.push(subpattern.join('\\s*'));
      R.push('\\s*(.*)');
      R.push('$');
      return new RegExp(R.join(''));
    };
    pattern = get_pattern(field_count);
    //.........................................................................................................
    return this.$((line, send) => {
      var R, field, i, idx, match, ref, type;
      if ((type = CND.type_of(line)) !== 'text') {
        `µ27918 expected a text, got a ${type}`;
      }
      // debug 'µ78765-1', ( rpr pattern ), ( rpr line )
      if ((indexOf.call(line, '\n') >= 0) || ((match = line.match(pattern)) == null)) {
        throw new Error(`µ43916 illegal line: ${rpr(line)}`);
      }
      match = [...match];
      R = [];
// debug 'µ78765-2', ( rpr pattern ), ( rpr line ), ( rpr match )
      for (idx = i = 1, ref = field_count; (1 <= ref ? i <= ref : i >= ref); idx = 1 <= ref ? ++i : --i) {
        R.push((field = match[idx]) === '' ? null : field);
      }
      return send(R);
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$trim_fields = function() {
    return this.$watch((fields) => {
      var field, i, idx, len, type;
      if ((type = CND.type_of(fields)) !== 'list') {
        throw new Error(`µ44017 expected a list, got a ${type}`);
      }
      for (idx = i = 0, len = fields.length; i < len; idx = ++i) {
        field = fields[idx];
        fields[idx] = field.trim();
      }
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$split_tsv = function() {
    var R;
    R = [];
    R.push(this.$split());
    // R.push @$trim()
    R.push(this.$skip_blank());
    /* TAINT use named method; allow to configure comment marker */
    R.push(this.$filter(function(line) {
      return !line.startsWith('#');
    }));
    R.push(this.$split_on_tabs());
    R.push(this.$trim_fields());
    return this.pull(...R);
  };

  //-----------------------------------------------------------------------------------------------------------
  /* TAINT use `settings` for extensibility */
  this.$split_wsv = function(field_count = null) {
    var R;
    R = [];
    R.push(this.$split());
    // R.push @$sample 1 / 20000
    // R.push @$trim()
    R.push(this.$skip_blank());
    /* TAINT use named method; allow to configure comment marker */
    R.push(this.$filter(function(line) {
      return !line.startsWith('#');
    }));
    R.push(this.$split_on_whitespace(field_count));
    return this.pull(...R);
  };

}).call(this);

//# sourceMappingURL=tsv.js.map
