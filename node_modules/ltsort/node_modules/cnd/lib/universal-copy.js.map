{
  "version": 3,
  "file": "universal-copy.js",
  "sourceRoot": "..",
  "sources": [
    "src/universal-copy.coffee"
  ],
  "names": [],
  "mappings": ";AAMG;EAAA;;;;;;EAEH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAFG",
  "sourcesContent": [
    "\n###\n\nhttps://github.com/loveencounterflow/universal-copy\nhttps://github.com/nrn/universal-copy\n\n###\n\n`\nvar OPtoString = Object.prototype.toString\nvar OPHas = Object.prototype.hasOwnProperty\n\nvar values = {\n  'string': true,\n  'number': true,\n  'boolean': true,\n  'symbol': true,\n  // Kinda a lie, but returning the functions unmodified\n  // leads to the least confusing behavior.\n  'function': true\n}\n\nvar howDoICopy = {\n  '[object Object]': copyObject,\n  '[object Array]': copyArray,\n  '[object Error]': justDont,\n  '[object Map]': copyMap,\n  '[object Set]': copySet,\n  '[object Date]': copyConstructor,\n  '[object RegExp]': copyConstructor,\n  '[object Promise]': justDont,\n  '[object XMLHttpRequest]': justDont,\n  '[object NodeList]': copyArray,\n  '[object ArrayBuffer]': copySlice,\n  '[object Int8Array]': copyConstructor,\n  '[object Uint8Array]': copyConstructor,\n  '[object Uint8ClampedArray]': copyConstructor,\n  '[object Int16Array]': copyConstructor,\n  '[object Uint16Array]': copyConstructor,\n  '[object Int32Array]': copyConstructor,\n  '[object Uint32Array]': copyConstructor,\n  '[object Float32Array]': copyConstructor,\n  '[object Float64Array]': copyConstructor\n}\n\nmodule.exports = universalCopy\n\nfunction universalCopy (anything) {\n  return deepCopy(anything, new FakeMap())\n}\n\nfunction deepCopy (original, seen) {\n  var type = typeof original\n\n  // Don't need to do anything for values\n  // that aren't passed by reference.\n  if (original == null || type in values) {\n    return original\n  }\n\n  // if this object has already been copied during\n  // this deep copy, use that first copy.\n  var extantClone = seen.get(original)\n  if (typeof extantClone !== 'undefined') {\n    return extantClone\n  }\n\n  // Copy buffers correctly in pre-TypedArray node versions\n  if (original.constructor &&\n      original.constructor.isBuffer &&\n      original.constructor.isBuffer(original)) {\n    return copyConstructor(original, seen)\n  }\n\n  if (typeof Element === 'function' &&\n      original instanceof Element) {\n    return cloneCopy(original, seen)\n  }\n\n  var copyX = howDoICopy[toStr(original)]\n  // if none of the special cases hit, copy original as a generic object.\n  return (copyX || copyObject)(original, seen)\n}\n\nfunction copyConstructor (original, seen) {\n  var copy = new original.constructor(original)\n  seen.set(original, copy)\n  return copy\n}\n\nfunction copySet (original, seen) {\n  var copy = new (original.constructor || Set)\n  seen.set(original, copy)\n  original.forEach(function (v) {\n    copy.add(deepCopy(v, seen))\n  })\n  return copy\n}\n\nfunction copyMap (original, seen) {\n  var copy = new (original.constructor || Map)\n  seen.set(original, copy)\n  original.forEach(function (v, k) {\n    copy.set(deepCopy(k, seen), deepCopy(v, seen))\n  })\n  return copy\n}\n\nfunction copySlice (original, seen) {\n  var copy = original.slice(0)\n  seen.set(original, copy)\n  return copy\n}\n\nfunction copyArray (original, seen) {\n  var copy = new Array(original.length)\n\n  seen.set(original, copy)\n  moveProps(original, copy, seen)\n  return copy\n}\n\nfunction cloneCopy (original, seen) {\n  var copy = original.cloneNode(true)\n  seen.set(original, copy)\n  return copy\n}\n\nfunction justDont (original, seen) {\n  return original\n}\n\nfunction copyObject (original, seen) {\n  var copy = Object.create(Object.getPrototypeOf(original))\n\n  seen.set(original, copy)\n\n  moveProps(original, copy, seen)\n\n  if (Object.isFrozen(original)) Object.freeze(copy)\n  if (Object.isSealed(original)) Object.seal(copy)\n  if (!Object.isExtensible(original)) Object.preventExtensions(copy)\n\n  return copy\n}\n\nfunction moveProps (original, copy, seen) {\n  Object.getOwnPropertyNames(original).forEach(originalToCopy)\n\n  if (typeof Object.getOwnPropertySymbols === 'function') {\n    Object.getOwnPropertySymbols(original).forEach(originalToCopy)\n  }\n\n  function originalToCopy (key) {\n    var descriptor = Object.getOwnPropertyDescriptor(original, key)\n    if (has(descriptor, 'value')) {\n      descriptor.value = deepCopy(descriptor.value, seen)\n    }\n    try {\n      Object.defineProperty(copy, key, descriptor)\n    } catch (e) {\n      // When define property fails it means we shouldn't\n      // have been trying to write the property we were.\n      // example: the stack of an error object.\n    }\n  }\n}\n\nfunction toStr (thing) {\n  return OPtoString.call(thing)\n}\n\nfunction has (thing, prop) {\n  return OPHas.call(thing, prop)\n}\n\n// Fake map only works for the few scenarios we need it for in this module.\n// it is _not_ a good Map polyfil.\nfunction FakeMap () {\n  if (typeof Map === 'function') return new Map()\n  this.keys = []\n  this.values = []\n}\nFakeMap.prototype.get = function (obj) {\n  var idx = this.keys.indexOf(obj)\n  if (idx !== -1) {\n    return this.values[idx]\n  }\n}\nFakeMap.prototype.set = function (key, value) {\n  this.keys.push(key)\n  this.values.push(value)\n}\n`"
  ]
}